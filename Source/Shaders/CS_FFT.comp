#version 460 core

#define WORK_GROUP_DIM 64

#define PI 3.14159265358979323846

layout (local_size_x = WORK_GROUP_DIM) in;

layout (binding = 0, rg32f) uniform readonly image2D u_input;
layout (binding = 1, rg32f) uniform writeonly image2D u_output;

uniform int u_total_count;
uniform int u_subseq_count;

vec2 MultiplyComplex(vec2 a, vec2 b)
{
	return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);
}

void main()
{
	int thread_count = int(u_total_count * 0.5f);
	int thread_idx = int(gl_GlobalInvocationID.x);

	int in_idx = thread_idx & (u_subseq_count - 1);		
	int out_idx = ((thread_idx - in_idx) << 1) + in_idx;

	float angle = -PI * (float(in_idx) / float(u_subseq_count));
	vec2 twiddle = vec2(cos(angle), sin(angle));

	vec2 a = imageLoad(u_input, thread_idx).xy;
	vec2 b = imageLoad(u_input, thread_idx + thread_count).xy;

	vec2 twiddle_b = MultiplyComplex(twiddle, b);
	vec2 out_a = a + twiddle_b;
	vec2 out_b = a - twiddle_b;

	imageStore(u_output, out_idx, vec4(out_a, 0.f, 1.f));
	imageStore(u_output, out_idx + u_subseq_count, vec4(out_b, 0.f, 1.f));
}

#if 0
void main()
{
	int idx = int(gl_GlobalInvocationID.x);
	float base = floor(idx / u_subtransform_count) * u_subtransform_count * 0.5f;
	float offset = mod(idx, u_subtransform_count * 0.5f);

	float x0 = base + offset;
	float x1 = x0 + u_transform_count * 0.5f;

	vec4 a = imageLoad(u_input, int(x0));
	vec4 b = imageLoad(u_input, int(x1));

	float angle = -2.f * PI * (float(idx) / float(u_subtransform_count));
	vec2 twiddle = vec2(cos(angle), sin(angle));

	vec2 out_val = a.xy + multiplyComplex(twiddle, b.xy);
	imageStore(u_output, idx, vec4(out_val, 0.f, 1.f));
}
#endif