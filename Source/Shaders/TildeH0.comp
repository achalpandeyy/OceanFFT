#version 460 core

#define PI_32F 3.14159265358979f
#define g 9.81f

layout (local_size_x = 32, local_size_y = 32) in;

uniform sampler2D s_Noise0;
uniform sampler2D s_Noise1;
uniform sampler2D s_Noise2;
uniform sampler2D s_Noise3;

layout(binding = 0, rg32f) writeonly uniform image2D tilde_h0_k;
layout(binding = 1, rg32f) writeonly uniform image2D tilde_h0_minus_k;

// Box Muller method
vec4 GaussianRandom()
{
	int u_N = 256;
	vec2 tex_coords = vec2(gl_GlobalInvocationID.xy) / float(u_N);
	
	// Uniform random numbers
	float a = clamp(texture(s_Noise0, tex_coords).r, 0.001f, 1.f);
	float b = clamp(texture(s_Noise1, tex_coords).r, 0.001f, 1.f);
	float c = clamp(texture(s_Noise2, tex_coords).r, 0.001f, 1.f);
	float d = clamp(texture(s_Noise3, tex_coords).r, 0.001f, 1.f);

	float u0 = 2.f * PI_32F * a;
	float v0 = sqrt(-2.f * log(b));
	float u1 = 2.f * PI_32F * c;
	float v1 = sqrt(-2.f * log(d));

	return vec4(v0 * cos(u0), v0 * sin(u0), v1 * cos(u1), v1 * sin(u1));
}

// Section 4.3, Eq 41
float SuppressionFactor(float k_magnitude_sq)
{
	float u_SuppressLength = 0.1f;
	return exp(-k_magnitude_sq * u_SuppressLength * u_SuppressLength);
}

// Phillips Spectrum, Section 4.3, Eq 40 
float PhillipsSpectrum(vec2 k, float k_magnitude_sq, float L_phillips)
{
	float u_Amplitude = 2.f;
	vec2 u_WindDirection = normalize(vec2(1.f, 1.f));
	return u_Amplitude * ((exp(-1.f / (k_magnitude_sq * L_phillips * L_phillips)) * pow(dot(normalize(k), u_WindDirection), 2))
		* SuppressionFactor(k_magnitude_sq)) / (k_magnitude_sq * k_magnitude_sq);
}

void main()
{
	int u_N = 256;
	int u_L = 1000;
	float u_WindSpeed = 80.f;

	vec2 pos = vec2(gl_GlobalInvocationID.xy) - (u_N / 2.f);

	// Wavevector, Section 4.3, Eq 36
	vec2 k = vec2((2.f * PI_32F * pos.x) / u_L, (2.f * PI_32F * pos.y) / u_L);

	float k_magnitude = length(k);
	if (k_magnitude < 0.00001f)	k_magnitude = 0.00001f;

	// Largest possible waves arising from a continuous wind of speed wind_speed, Section 4.3, after Eq 40
	float L_phillips = (u_WindSpeed * u_WindSpeed) / g;

	// Todo: Do you need to clamp values of h0_k here?
	// Section 4.4, Eq 42
	float h0_k = sqrt(PhillipsSpectrum(k, k_magnitude * k_magnitude, L_phillips) / 2.f);
	float h0_minus_k = sqrt(PhillipsSpectrum(-k, k_magnitude * k_magnitude, L_phillips) / 2.f);

	vec4 rnd = GaussianRandom();

	ivec2 pixel_pos = ivec2(gl_GlobalInvocationID.xy);
	imageStore(tilde_h0_k, pixel_pos, vec4(rnd.xy * h0_k, 0.f, 1.f));
	imageStore(tilde_h0_minus_k, pixel_pos, vec4(rnd.zw * h0_minus_k, 0.f, 1.f));
}