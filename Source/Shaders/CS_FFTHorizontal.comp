#version 460 core

#define WORK_GROUP_DIM 256 // I want 256 threads (since N/2) per work group

#define PI 3.14159265358979323846

layout (local_size_x = WORK_GROUP_DIM) in;

layout (binding = 0, rg32f) uniform readonly image2D u_input;
layout (binding = 1, rg32f) uniform writeonly image2D u_output;

uniform int u_total_count;
uniform int u_subseq_count;

vec2 MultiplyComplex(vec2 a, vec2 b)
{
	return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);
}

#if 1
void main()
{
	ivec2 pixel_coord = ivec2(gl_LocalInvocationID.x, gl_WorkGroupID.x);

	int thread_count = int(u_total_count * 0.5f);
	int thread_idx = pixel_coord.x;

	int in_idx = thread_idx & (u_subseq_count - 1);		
	int out_idx = ((thread_idx - in_idx) << 1) + in_idx;

	float angle = -PI * (float(in_idx) / float(u_subseq_count));
	vec2 twiddle = vec2(cos(angle), sin(angle));

	vec2 a = imageLoad(u_input, pixel_coord).xy;
	vec2 b = imageLoad(u_input, ivec2(pixel_coord.x + thread_count, pixel_coord.y)).xy;

	vec2 twiddle_b = MultiplyComplex(twiddle, b);
	vec2 out_a = a + twiddle_b;
	vec2 out_b = a - twiddle_b;

	imageStore(u_output, ivec2(out_idx, pixel_coord.y), vec4(out_a, 0.f, 1.f));
	imageStore(u_output, ivec2(out_idx + u_subseq_count, pixel_coord.y), vec4(out_b, 0.f, 1.f));
}
#endif

#if 0
void main()
{
	ivec2 pixel_coord = ivec2(gl_LocalInvocationID.x, gl_WorkGroupID.x);

	float index = pixel_coord.x;
	float evenIndex = floor(index / u_subseq_count) * (u_subseq_count * 0.5f) + mod(index, u_subseq_count * 0.5f);
	
	vec2 even = imageLoad(u_input, ivec2(evenIndex, pixel_coord.y)).rg;
	vec2 odd = imageLoad(u_input, ivec2(evenIndex + u_total_count * 0.5f, pixel_coord.y)).rg;
	
	float twiddleArgument = -2.f * PI * (index / u_subseq_count);
	vec2 twiddle = vec2(cos(twiddleArgument), sin(twiddleArgument));
	
	vec2 outputA = even.xy + MultiplyComplex(twiddle, odd.xy);
	// vec2 outputB = even.zw + MultiplyComplex(twiddle, odd.zw);

	imageStore(u_output, pixel_coord, vec4(outputA, 0.f, 1.f));

	// int idx = int(gl_GlobalInvocationID.x);
	// float base = floor(idx / u_subtransform_count) * u_subtransform_count * 0.5f;
	// float offset = mod(idx, u_subtransform_count * 0.5f);
	// 
	// float x0 = base + offset;
	// float x1 = x0 + u_transform_count * 0.5f;
	// 
	// vec4 a = imageLoad(u_input, int(x0));
	// vec4 b = imageLoad(u_input, int(x1));
	// 
	// float angle = -2.f * PI * (float(idx) / float(u_subtransform_count));
	// vec2 twiddle = vec2(cos(angle), sin(angle));
	// 
	// vec2 out_val = a.xy + multiplyComplex(twiddle, b.xy);
	// imageStore(u_output, idx, vec4(out_val, 0.f, 1.f));
}
#endif